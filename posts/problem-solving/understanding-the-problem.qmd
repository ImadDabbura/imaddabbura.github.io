---
title: "Understand, Then Build"
subtitle: "How Pólya’s Step 1 powers reliable DS/ML/AI systems under real-world limits."
image: "images/feature.jpeg"
date: "2025-03-05"
date-modified: "2025-03-05"
categories: MLSys
---
*Part 1 of 4: Applying Polya's Problem-Solving Framework to Data Science, ML, and AI*

*A Comprehensive Guide for Practitioners*


## **Introduction: The Hidden Crisis in AI Development**

In the rush to implement cutting-edge machine learning solutions, organizations across industries are encountering a troubling pattern of failure. Despite unprecedented investment in AI technologies and the availability of sophisticated algorithms, the vast majority of data science projects never deliver their promised value. Recent studies reveal that approximately 87% of data science projects fail to reach production, while those that do often fail to meet their original objectives. This crisis isn't primarily technical in nature—it stems from a fundamental misunderstanding of the problems these systems are meant to solve.George Polya, the renowned Hungarian mathematician, anticipated this challenge decades before the advent of modern computing. In his 1945 masterwork "How to Solve It," Polya articulated a truth that resonates even more strongly in our age of artificial intelligence: the most critical phase of problem-solving occurs before any solution is attempted. His systematic framework for problem understanding, originally developed for mathematical reasoning, provides exactly the rigor and structure that modern data science desperately needs.

The challenge of problem understanding in artificial intelligence extends far beyond the difficulties encountered in traditional software development. When building conventional systems, requirements typically manifest as concrete specifications—a form must capture specific fields, a report must display particular metrics, an API must return defined responses. These requirements, while sometimes complex, exist in the realm of the deterministic and the definable. Machine learning problems, however, inhabit a fundamentally different space. They deal with probabilities rather than certainties, with patterns rather than rules, with approximations rather than exact solutions.

Consider the seemingly straightforward task of building a customer churn prediction model. The surface-level requirement appears simple: identify customers likely to cancel their subscriptions. Yet beneath this simplicity lies a web of critical questions that must be answered with precision. What exactly constitutes churn in this context? Is it the moment a customer clicks the cancellation button, the end of their billing period, or the point at which they stop engaging with the service? Over what time horizon should predictions be made—next week, next month, or next quarter? What level of confidence is required for the prediction to trigger an intervention? What are the relative costs of false positives versus false negatives? Each of these questions, if answered incorrectly or left unexamined, can render even the most sophisticated model useless in practice.

The compounding nature of misunderstanding in AI projects deserves particular attention. When a problem is misunderstood by even a small margin at the outset, this error doesn't simply add a proportional amount of waste to the project. Instead, it multiplies through each subsequent phase, creating an exponential cascade of inefficiency. A 10% misalignment in problem definition becomes a 20% misdirection in planning, as architects design systems for the wrong objectives. This doubles again during implementation, reaching 40% waste as engineers optimize for incorrect metrics. By the deployment phase, the cumulative effect can result in 80% waste—or complete project failure.

![](images/cascading-cost.svg)

## **The Three Pillars of Problem Understanding**

### **What is the Unknown? The Art of Target Definition**

Polya's first fundamental question—"What is the unknown?"—appears deceptively simple. In mathematical problems, the unknown might be a single variable or a proof to be demonstrated. In machine learning, however, the unknown encompasses not just what we're predicting, but the entire context in which that prediction exists and will be used.

The specification of the unknown in a machine learning context requires us to think across multiple dimensions simultaneously. We must consider not only the technical nature of the prediction—whether it's a continuous value, a category, or a probability—but also its temporal characteristics, its intended use, and its relationship to business processes. A prediction that arrives too late to be actionable is worthless, regardless of its accuracy. A highly accurate model that requires data unavailable at inference time is an elaborate fiction. A probabilistic output that decision-makers don't understand how to interpret might as well be random noise.

![](images/types-ml-unknowns.svg)

```python
# pseudocode
def validate_target_specification(target_spec):
    """
    Comprehensive validation of target variable definition
    Ensures all aspects of the unknown are properly specified
    """
    
    validation_results = {}
    
    // Check temporal alignment
    IF target_spec.prediction_horizon is NULL:
        validation_results.add_error("Prediction horizon not specified")
    ELSE IF target_spec.prediction_horizon < data_availability_lag:
        validation_results.add_error("Cannot predict before data available")
    
    // Check actionability window
    IF target_spec.action_deadline < target_spec.prediction_horizon:
        validation_results.add_error("Prediction arrives too late for action")
    
    // Check measurement feasibility
    IF target_spec.ground_truth_delay > evaluation_window:
        validation_results.add_warning("Cannot measure success in reasonable time")
    
    // Check business alignment
    IF target_spec.decision_threshold is NULL:
        validation_results.add_error("No decision threshold specified")
    ELSE:
        expected_precision = estimate_precision(target_spec.decision_threshold)
        IF expected_precision < target_spec.minimum_precision:
            validation_results.add_warning("Threshold may not meet precision requirements")
    
    // Check data sufficiency
    positive_examples = count_historical_positives(target_spec)
    IF positive_examples < 100 * number_of_features:
        validation_results.add_error("Insufficient positive examples for reliable learning")
    
    // Check for label leakage
    FOR each feature in available_features:
        IF feature.creation_time > target_spec.event_time:
            validation_results.add_error(f"Feature {feature} contains future information")
    
    return validation_results
```

The temporal dimension of the unknown often proves particularly challenging for practitioners to specify correctly. Consider a financial institution developing a loan default prediction model. Stating that the model should "predict loan defaults" leaves enormous ambiguity. Should it predict the probability of default at any point during the loan's lifetime? Within the first year? Within the next payment period? The answer fundamentally changes the problem structure, the relevant features, the appropriate evaluation metrics, and the business value of the solution. A model predicting lifetime default risk might be valuable for initial underwriting decisions but useless for portfolio management, where the question is which current loans are likely to default in the near term.

Furthermore, the unknown in machine learning problems often involves multiple interconnected predictions rather than a single output. A recommendation system doesn't just predict what items a user might like; it must also predict the probability of engagement, the likely order value, the potential for cross-selling, and perhaps the long-term impact on customer satisfaction. These multiple unknowns must be carefully balanced and their relationships explicitly modeled. The tendency to oversimplify complex business problems into single prediction tasks has been the downfall of countless AI initiatives.

The granularity at which the unknown is defined presents another critical consideration. Should a demand forecasting model predict at the SKU level, category level, or store level? Should it provide daily, weekly, or monthly forecasts? The answers depend not only on the available data and computational resources but more fundamentally on how the predictions will be used. A buyer making quarterly purchasing decisions needs different granularity than a store manager optimizing daily staff schedules. Understanding these use cases and their requirements must precede any technical decisions about model architecture or feature engineering.

### What are the Data? Beyond Simple Statistics

Polya's second question—"What are the data?"—requires us to understand not just what information we have, but what that information truly represents, how it was generated, and what it can and cannot tell us about our unknown. In the context of machine learning, data understanding extends far beyond calculating summary statistics or visualizing distributions. It requires a deep investigation into the data's provenance, its biases, its temporal characteristics, and its relationship to the phenomenon we're trying to model.

The provenance of data—its origin and the process by which it was collected—fundamentally determines what problems it can solve. Data collected for one purpose often carries implicit assumptions that make it unsuitable for other uses. Customer service logs, for instance, only capture information about customers who contacted support, creating a selection bias that might invalidate models trying to understand overall customer satisfaction. Transaction data might only record completed purchases, missing the crucial information about abandoned carts that would be essential for understanding purchase intent. Understanding these collection mechanisms and their limitations is essential for determining whether available data can actually answer the questions being asked.

![](images/data-understanding-iceberg.svg)

```python
# pseudocode
def assess_data_provenance(dataset):
    """
    Deep investigation of data origin and collection biases
    Returns comprehensive assessment of data limitations
    """
    
    provenance_report = {}
    
    // Analyze collection mechanism
    collection_method = identify_collection_method(dataset)
    IF collection_method == "user_voluntary":
        provenance_report.bias = "self-selection bias likely"
        provenance_report.missing_population = estimate_non_participants()
    ELSE IF collection_method == "automated_sensors":
        provenance_report.bias = "measurement conditions may vary"
        provenance_report.accuracy = assess_sensor_calibration()
    ELSE IF collection_method == "human_annotation":
        provenance_report.bias = "annotator subjectivity present"
        provenance_report.consistency = calculate_inter_annotator_agreement()
    
    // Temporal coverage analysis
    data_time_range = get_temporal_range(dataset)
    FOR each major_event in business_timeline:
        IF major_event.date in data_time_range:
            provenance_report.add_discontinuity(major_event)
    
    // Population coverage
    represented_segments = identify_data_segments(dataset)
    target_population = get_target_population()
    FOR each segment in target_population:
        IF segment not in represented_segments:
            provenance_report.add_missing_segment(segment)
        ELSE:
            representation_ratio = calculate_representation(segment)
            IF representation_ratio < 0.8:
                provenance_report.add_underrepresented(segment, representation_ratio)
    
    // Identify systematic gaps
    missing_pattern = analyze_missing_patterns(dataset)
    IF missing_pattern.type == "MNAR":  // Missing Not At Random
        provenance_report.critical_warning = "Missing data is informative"
        provenance_report.affected_features = missing_pattern.correlated_features
    
    return provenance_report
```

The temporal characteristics of data present particular challenges in machine learning applications. Most business data exhibits complex temporal patterns—seasonality, trends, periodic events, and gradual distribution shifts. A dataset that appears rich and comprehensive when viewed in aggregate might reveal serious gaps when examined temporally. Consider an e-commerce company with five years of transaction data. This might seem sufficient for building a robust demand forecasting model until temporal analysis reveals that a major website redesign two years ago fundamentally changed user behavior, effectively limiting usable data to a much shorter period. Similarly, data that seems current might actually have significant reporting delays, making real-time prediction impossible regardless of model sophistication.

The relationship between available data and the target variable often proves more complex than initially assumed. Surface-level correlations might mask confounding variables, while truly predictive features might be hidden in complex interactions or temporal patterns. A retail model trying to predict product returns might find high correlation with certain product categories, but deeper investigation might reveal that the actual driver is shipping distance, with certain categories simply happening to be ordered more frequently from distant locations. This kind of insight only emerges from thorough data understanding that goes beyond statistical analysis to examine causal relationships and business logic.

Data quality issues compound these challenges. Missing data rarely occurs randomly; the mechanism of missingness often contains information itself. Customers who don't provide income information might systematically differ from those who do. Sensors that fail to report might do so under specific conditions that are precisely the ones we need to understand. These patterns of missingness must be understood not just to handle them technically but to determine whether the available data can support valid inference about the unknown.

### What is the Condition? The Constraint Ecosystem

Polya's third question—"What is the condition?"—addresses the constraints that bound our solution space. In machine learning applications, these constraints form a complex ecosystem of technical, business, ethical, and regulatory requirements that often conflict with each other and always shape the feasible solution space in non-obvious ways.

![](images/ml-constraint-ecosystem.svg)

Technical constraints in modern machine learning systems extend well beyond simple computational limitations. Latency requirements for real-time systems must account not just for model inference time but for data retrieval, preprocessing, and post-processing. A fraud detection system that must respond within 100 milliseconds cannot use a model that requires complex feature engineering on historical data, regardless of how much that engineering might improve accuracy. Similarly, models deployed on edge devices face strict constraints on memory usage and computational complexity that eliminate entire classes of algorithms from consideration. These technical constraints must be understood not as implementation details to be addressed later but as fundamental aspects of the problem that shape what solutions are possible.

Business constraints often prove even more restrictive than technical ones. Budget limitations don't just affect the choice of infrastructure; they determine how much data can be labeled, how frequently models can be retrained, and how sophisticated the monitoring systems can be. Timeline constraints might force choices between building a comprehensive solution that arrives too late to capture value and a simpler solution that can be deployed while the opportunity still exists. Organizational constraints—the skills available on the team, the maturity of data infrastructure, the sophistication of end users—all fundamentally shape what kinds of solutions can be successfully deployed and maintained.

The ethical and regulatory constraints on machine learning systems have rightfully become a central concern, yet they're often treated as an afterthought rather than a fundamental aspect of problem definition. Requirements for model explainability, fairness across protected groups, privacy preservation, and regulatory compliance aren't features to be added after the fact—they're core constraints that must shape the solution from the beginning. A loan approval model that must provide adverse action notices under the Equal Credit Opportunity Act cannot use a black-box ensemble method, regardless of its superior predictive performance. A healthcare diagnostic system that must maintain patient privacy under HIPAA cannot use collaborative filtering approaches that might leak information between patients.

These various constraints don't exist in isolation; they interact in complex ways that create the actual solution space. High accuracy requirements might conflict with explainability needs. Real-time latency requirements might conflict with the desire for sophisticated feature engineering. Privacy requirements might conflict with the need for detailed user profiling. Understanding these interactions and their implications requires careful analysis before any model development begins. The feasible solution space is often much smaller than initially assumed, and discovering this after significant investment in development can be catastrophic for project success.

```python
# pseudocode
def analyze_constraint_interactions(constraints):
    """
    Identify conflicts between constraints and determine feasible solution space
    Returns feasibility assessment and recommended trade-offs
    """
    
    conflicts = []
    solution_space = initialize_full_space()
    
    // Check for fundamental incompatibilities
    FOR each constraint_pair in combinations(constraints, 2):
        conflict_type = check_compatibility(constraint_pair)
        
        IF conflict_type == "HARD_CONFLICT":
            conflicts.append({
                "type": "incompatible",
                "constraints": constraint_pair,
                "resolution": "must_choose_one"
            })
            solution_space = NULL
            
        ELSE IF conflict_type == "SOFT_CONFLICT":
            conflicts.append({
                "type": "trade-off",
                "constraints": constraint_pair,
                "pareto_frontier": calculate_pareto_frontier(constraint_pair)
            })
            solution_space = intersect(solution_space, constraint_pair.feasible_region)
    
    // Analyze solution space
    IF solution_space == NULL:
        return {
            "feasible": False,
            "reason": "Hard conflicts exist",
            "conflicts": conflicts
        }
    
    IF volume(solution_space) < minimum_viable_space:
        return {
            "feasible": False,
            "reason": "Solution space too constrained",
            "bottleneck": identify_binding_constraints(constraints)
        }
    
    // Find optimal point within feasible space
    optimal_point = optimize_within_constraints(solution_space, business_objective)
    
    return {
        "feasible": True,
        "solution_space": solution_space,
        "recommended_approach": optimal_point,
        "trade_offs": conflicts,
        "flexibility": calculate_robustness(solution_space)
    }
```

## The Process of Problem Decomposition

Polya emphasized that complex problems become manageable when properly decomposed into smaller, more tractable components. In machine learning applications, this decomposition must occur across multiple dimensions simultaneously, breaking down the problem by temporal characteristics, functional components, data complexity, and stakeholder concerns.

![](images/problem-decomposition-strategies.svg)

Temporal decomposition recognizes that different aspects of a machine learning system operate on different time scales and have different latency requirements. Consider a recommendation system for an e-commerce platform. The real-time serving layer must respond within milliseconds, showing pre-computed recommendations to users as they browse. The batch processing layer might update user embeddings hourly, incorporating recent behavior while maintaining computational efficiency. The model retraining pipeline might run daily or weekly, incorporating new data and adapting to changing patterns. The fundamental model architecture might be revisited monthly or quarterly, based on accumulated performance data and changing business requirements. Each of these temporal components has different requirements, different constraints, and different success metrics, yet they must work together as a cohesive system.

Functional decomposition breaks the overall prediction task into logical sub-problems that can be solved independently and then combined. A customer lifetime value prediction system might decompose into predicting whether a customer will make another purchase (a classification problem), how many purchases they'll make (a count regression problem), and the average value of those purchases (a value regression problem). Each component can be optimized separately with appropriate techniques and then combined to produce the final prediction. This decomposition not only simplifies the modeling challenge but also provides interpretability and debugging advantages—when the system fails, it's easier to identify which component is responsible.

```python
# pseudocode
def decompose_ml_problem(problem_spec):
    """
    Systematic decomposition across multiple dimensions
    Returns structured decomposition plan with dependencies
    """
    
    decomposition = {
        "temporal": [],
        "functional": [],
        "data": [],
        "stakeholder": []
    }
    
    // Temporal decomposition
    time_requirements = analyze_time_requirements(problem_spec)
    FOR each time_scale in ["real_time", "near_real_time", "batch", "periodic"]:
        IF time_scale in time_requirements:
            component = {
                "scale": time_scale,
                "latency": get_latency_requirement(time_scale),
                "update_frequency": get_update_frequency(time_scale),
                "infrastructure": map_to_infrastructure(time_scale)
            }
            decomposition.temporal.append(component)
    
    // Functional decomposition
    sub_problems = identify_sub_problems(problem_spec)
    FOR each sub_problem in sub_problems:
        component = {
            "name": sub_problem.name,
            "type": classify_problem_type(sub_problem),
            "algorithm_family": suggest_algorithms(sub_problem),
            "evaluation_metric": select_metric(sub_problem),
            "dependencies": identify_dependencies(sub_problem, sub_problems)
        }
        decomposition.functional.append(component)
    
    // Data complexity ladder
    data_sources = identify_data_sources(problem_spec)
    complexity_levels = []
    cumulative_data = []
    
    FOR complexity in ["structured", "text", "images", "temporal", "graph"]:
        available = filter_by_type(data_sources, complexity)
        IF available:
            cumulative_data.extend(available)
            level = {
                "version": f"v{len(complexity_levels) + 1}",
                "data_types": cumulative_data.copy(),
                "expected_improvement": estimate_improvement(cumulative_data),
                "additional_effort": estimate_effort(available)
            }
            complexity_levels.append(level)
    
    decomposition.data = complexity_levels
    
    // Stakeholder perspectives
    stakeholders = identify_stakeholders(problem_spec)
    FOR each stakeholder in stakeholders:
        perspective = {
            "group": stakeholder.name,
            "success_criteria": stakeholder.get_success_metrics(),
            "constraints": stakeholder.get_constraints(),
            "concerns": stakeholder.get_concerns(),
            "communication_needs": define_reporting(stakeholder)
        }
        decomposition.stakeholder.append(perspective)
    
    // Validate decomposition coherence
    validation = validate_decomposition(decomposition)
    IF not validation.is_coherent:
        decomposition.warnings = validation.issues
    
    return decomposition
```

The decomposition by data complexity allows teams to build incrementally, starting with simpler data sources and gradually incorporating more complex ones as the system matures. The first version might use only structured transactional data, establishing a baseline and proving the basic concept. Subsequent versions might incorporate unstructured text from customer reviews, clickstream data from website interactions, or external data sources like economic indicators. This incremental approach reduces risk, allows for faster initial deployment, and provides clear decision points about whether additional complexity is justified by improved performance.

Stakeholder decomposition recognizes that different groups have different perspectives on the problem and different requirements for the solution. The data science team focuses on model performance metrics, the engineering team on system reliability and maintainability, the business team on ROI and strategic alignment, the legal team on compliance and risk, and the end users on usability and trustworthiness. Each perspective reveals different aspects of the problem and different constraints on the solution. Successful problem understanding requires synthesizing these perspectives into a coherent whole while managing the inevitable conflicts between them.

## The Art of Feasibility Assessment

Before committing resources to solving a problem, Polya advocates for carefully assessing whether the conditions can actually be satisfied—whether the problem as stated is actually solvable with the available resources. In machine learning contexts, this feasibility assessment must examine statistical, technical, business, and ethical dimensions.

![](images/ml-feasibility-assessment-matrix.svg)

Statistical feasibility begins with the fundamental question of whether the available data contains sufficient signal to predict the target variable. This goes beyond simple correlation analysis to examine the theoretical limits of predictability. Some phenomena are inherently unpredictable beyond a certain accuracy level—no amount of data or model sophistication will predict truly random events. Other phenomena might be theoretically predictable but require data that doesn't exist or cannot be collected. A model attempting to predict customer satisfaction might fail not because of poor algorithms but because satisfaction is influenced by factors—personal circumstances, competitive offerings, unrecorded service interactions—that aren't captured in any available data.

The sample size requirements for machine learning often surprise stakeholders accustomed to traditional statistics. While classical statistical methods might require dozens or hundreds of samples, machine learning models, particularly deep learning approaches, might require thousands or millions of examples to achieve acceptable performance. Moreover, these samples must adequately represent all scenarios the model will encounter in production. A fraud detection model trained on historical data might fail catastrophically when fraudsters develop new techniques not represented in the training set. Understanding these sample requirements and their implications for data collection costs and timelines is essential for realistic project planning.

```python
# pseudocode
def assess_statistical_feasibility(data, target, requirements):
    """
    Comprehensive statistical feasibility assessment
    Returns detailed analysis of whether ML can solve this problem
    """
    
    feasibility_report = {
        "overall": "UNKNOWN",
        "details": {},
        "recommendations": []
    }
    
    // 1. Sample size analysis
    n_samples = len(data)
    n_features = data.shape[1]
    n_classes = target.nunique() if is_classification else None
    
    // Rules of thumb for different model types
    min_samples = {
        "linear": n_features * 10,
        "tree_based": n_features * 50,
        "neural_network": n_features * 100,
        "deep_learning": n_features * 1000
    }
    
    feasibility_report.details["sample_size"] = {
        "available": n_samples,
        "requirements": min_samples,
        "verdict": determine_adequacy(n_samples, min_samples)
    }
    
    // 2. Signal-to-noise analysis
    IF is_classification:
        // Use mutual information for classification
        mi_scores = mutual_information(data, target)
        signal_strength = mean(mi_scores)
        noise_estimate = estimate_bayes_error_rate(data, target)
    ELSE:
        // Use correlation and R² for regression
        correlations = [correlation(feature, target) for feature in data]
        signal_strength = max(correlations)
        noise_estimate = 1 - best_possible_r2(data, target)
    
    feasibility_report.details["signal"] = {
        "strength": signal_strength,
        "noise_level": noise_estimate,
        "predictability_ceiling": 1 - noise_estimate,
        "verdict": "GOOD" if signal_strength > 0.3 else "WEAK"
    }
    
    // 3. Class imbalance assessment (for classification)
    IF is_classification:
        class_distribution = target.value_counts(normalize=True)
        minority_class = min(class_distribution)
        
        IF minority_class < 0.01:
            feasibility_report.details["class_balance"] = {
                "minority_ratio": minority_class,
                "verdict": "SEVERE_IMBALANCE",
                "min_samples_minority": n_samples * minority_class,
                "recommendation": "Consider anomaly detection instead"
            }
        ELSE IF minority_class < 0.1:
            feasibility_report.details["class_balance"] = {
                "minority_ratio": minority_class,
                "verdict": "MODERATE_IMBALANCE",
                "recommendation": "Will need resampling strategies"
            }
    
    // 4. Feature informativeness
    redundancy_matrix = calculate_feature_redundancy(data)
    effective_features = count_non_redundant_features(redundancy_matrix)
    
    feasibility_report.details["features"] = {
        "total": n_features,
        "effective": effective_features,
        "redundancy": 1 - (effective_features / n_features),
        "verdict": "GOOD" if effective_features > 10 else "INSUFFICIENT"
    }
    
    // 5. Temporal stability (if applicable)
    IF has_temporal_component(data):
        drift_analysis = detect_distribution_drift(data, time_column)
        feasibility_report.details["stability"] = {
            "drift_detected": drift_analysis.significant_drift,
            "drift_magnitude": drift_analysis.magnitude,
            "verdict": "UNSTABLE" if drift_analysis.significant_drift else "STABLE"
        }
    
    // Overall verdict
    critical_failures = [
        v["verdict"] for v in feasibility_report.details.values() 
        if v["verdict"] in ["FAIL", "SEVERE_IMBALANCE", "INSUFFICIENT"]
    ]
    
    IF len(critical_failures) > 0:
        feasibility_report["overall"] = "NOT_FEASIBLE"
        feasibility_report["recommendations"].append("Address critical issues before proceeding")
    ELSE IF any_marginal_verdicts(feasibility_report.details):
        feasibility_report["overall"] = "CONDITIONALLY_FEASIBLE"
        feasibility_report["recommendations"].append("Proceed with risk mitigation strategies")
    ELSE:
        feasibility_report["overall"] = "FEASIBLE"
        feasibility_report["recommendations"].append("Green light to proceed")
    
    return feasibility_report
```

Technical feasibility extends beyond simple computational requirements to encompass the entire lifecycle of the machine learning system. Can the necessary data be accessed with acceptable latency? Can feature engineering be performed within the required time constraints? Can models be retrained frequently enough to adapt to changing patterns? Can predictions be delivered to downstream systems reliably? Can model performance be monitored effectively in production? Each of these questions must be answered affirmatively, with specific technical solutions identified, before proceeding with development.

Business feasibility requires honest assessment of whether the predicted improvements justify the investment required. This calculation must account not just for initial development costs but for ongoing maintenance, periodic retraining, and eventual replacement. It must consider opportunity costs—what other projects could be pursued with the same resources? It must evaluate risk—what happens if the model performs worse than expected or fails entirely? And it must assess organizational readiness—does the organization have the processes and culture to effectively use model predictions in decision-making?

Ethical feasibility has become increasingly critical as machine learning systems influence more consequential decisions. Can the model achieve acceptable performance across all demographic groups? Can its decisions be explained to affected individuals? Can privacy be preserved while still achieving business objectives? Can the system be audited for bias and fairness? These aren't just nice-to-have features but fundamental requirements that, if not achievable, should halt project development before resources are wasted on an ultimately undeployable system.

## Creating Shared Understanding Across Teams

One of Polya's key insights was the importance of notation—creating a precise, shared language for discussing the problem. In machine learning projects, this shared understanding must bridge the gap between technical teams who think in terms of algorithms and metrics, and business stakeholders who think in terms of processes and outcomes.

![](images/technical-business-bridge.svg)

The creation of this shared understanding begins with establishing clear definitions for all key terms. What exactly does "customer" mean in the context of this problem—someone who has ever made a purchase, someone who has purchased within the last year, or someone who currently has an active subscription? What constitutes "engagement"—any interaction with the platform, specific high-value actions, or sustained activity over time? These definitions might seem pedantic, but ambiguity at this stage cascades through the entire project, leading to misaligned efforts and failed deployments.

Visual representations play a crucial role in creating shared understanding. System diagrams that show how predictions flow through business processes help stakeholders understand not just what the model predicts but how those predictions create value. Confusion matrices translated into business terms—showing dollar impacts rather than abstract metrics—make model performance tangible for non-technical stakeholders. Process flow diagrams that highlight where human judgment intersects with model predictions clarify the boundaries of automation and the importance of human oversight.

The translation between technical and business metrics requires particular care. A data scientist might celebrate achieving an AUC-ROC of 0.92, but this means nothing to a business stakeholder. Translating this into business terms—"the model correctly ranks risky customers 92% of the time, allowing us to focus retention efforts on those most likely to churn"—creates meaningful understanding. Similarly, technical constraints must be translated into business implications. A latency requirement of 100 milliseconds isn't just a technical specification; it means the model must make predictions fast enough to influence the customer experience without causing frustrating delays.

```python
# pseudocode
def create_stakeholder_communication_plan(project_spec, stakeholders):
    """
    Develop comprehensive communication strategy for all stakeholder groups
    Ensures consistent understanding across technical and business teams
    """
    
    communication_plan = {
        "vocabulary": {},
        "metrics_mapping": {},
        "update_cadence": {},
        "decision_points": []
    }
    
    // Create unified vocabulary
    technical_terms = extract_technical_terms(project_spec)
    FOR each term in technical_terms:
        translation = {
            "technical_definition": term.technical_meaning,
            "business_translation": translate_to_business(term),
            "example_in_context": create_concrete_example(term),
            "visual_representation": suggest_visualization(term)
        }
        communication_plan.vocabulary[term] = translation
    
    // Map technical metrics to business outcomes
    FOR each metric in project_spec.evaluation_metrics:
        mapping = {
            "technical_metric": metric.name,
            "calculation": metric.formula,
            "business_meaning": map_to_business_outcome(metric),
            "threshold_implications": {}
        }
        
        // Show what different threshold values mean
        FOR threshold in [0.5, 0.7, 0.9, 0.95, 0.99]:
            impact = calculate_business_impact(metric, threshold)
            mapping.threshold_implications[threshold] = {
                "true_positives": impact.correct_predictions,
                "false_positives": impact.false_alarms,
                "business_value": impact.net_value,
                "user_experience": describe_ux_impact(impact)
            }
        
        communication_plan.metrics_mapping[metric.name] = mapping
    
    // Define update cadence for each stakeholder group
    FOR each stakeholder_group in stakeholders:
        cadence = {
            "frequency": determine_update_frequency(stakeholder_group),
            "format": select_communication_format(stakeholder_group),
            "key_metrics": filter_relevant_metrics(stakeholder_group),
            "depth_of_detail": calibrate_technical_depth(stakeholder_group)
        }
        communication_plan.update_cadence[stakeholder_group] = cadence
    
    // Identify critical decision points
    decision_points = identify_project_gates(project_spec)
    FOR each decision_point in decision_points:
        gate = {
            "milestone": decision_point.name,
            "criteria": decision_point.success_criteria,
            "stakeholders_required": decision_point.approvers,
            "information_needed": prepare_decision_package(decision_point),
            "fallback_plan": define_contingency(decision_point)
        }
        communication_plan.decision_points.append(gate)
    
    return communication_plan
```

Regular communication rituals that bring together technical and business stakeholders help maintain aligned understanding as the project evolves. Problem definition workshops at the project's outset establish shared vocabulary and objectives. Regular review sessions during development ensure that technical choices align with business needs. Pre-deployment validations confirm that the solution actually addresses the original problem. These touchpoints prevent the gradual drift that often occurs when teams work in isolation.

## Common Anti-Patterns in Problem Understanding

Experience across numerous failed machine learning projects reveals recurring patterns of problem misunderstanding. Recognizing these anti-patterns early can prevent significant waste and frustration.

![](images/ml-problem-understanding-antipatterns.svg)

The "solution in search of a problem" anti-pattern occurs when teams become enamored with a particular technology or approach and then look for ways to apply it, rather than starting with a clear problem and finding the appropriate solution. This might manifest as insistence on using deep learning for problems where simple linear models would suffice, or forcing all problems into a supervised learning framework when unsupervised or reinforcement learning might be more appropriate. The result is unnecessary complexity, increased development time, and solutions that poorly match actual needs.

The "metric fixation" anti-pattern involves optimizing for easily measurable metrics while losing sight of actual business objectives. A recommendation system might achieve high click-through rates by recommending popular items everyone already knows about, failing in its actual purpose of discovery. A customer service bot might minimize average handling time by quickly closing conversations without actually resolving issues. The key to avoiding this anti-pattern is maintaining clear connection between model metrics and business outcomes, regularly validating that improvements in the former actually drive the latter.

The "perfect prediction" anti-pattern assumes that if we just had enough data and sophisticated enough models, we could predict outcomes with near-perfect accuracy. This ignores the inherent uncertainty in many business processes, the influence of external factors not captured in any dataset, and the reflexive nature of predictions that influence the outcomes they're trying to predict. Accepting the limits of predictability and designing systems that work well despite uncertainty is essential for practical success.

The "batch thinking in a streaming world" anti-pattern occurs when teams design solutions based on static datasets without considering the dynamic nature of production environments. Models trained on carefully curated historical data might fail when deployed to handle real-time streams with missing values, delayed updates, and distribution shifts. Understanding the temporal characteristics of both the problem and the production environment from the outset prevents expensive redesigns during deployment.

## Industry-Specific Considerations

While Polya's framework applies universally, its application must be tailored to the specific contexts and constraints of different industries. Each sector brings unique challenges that shape how problems must be understood and defined.

In healthcare applications, problem understanding must account for the life-or-death consequences of predictions, the stringent regulatory environment, and the complex interplay between statistical and clinical significance. A model that achieves high accuracy in predicting disease might still be clinically useless if it doesn't provide predictions early enough for intervention or if its false positives lead to unnecessary and harmful treatments. The problem definition must incorporate clinical workflows, consider the psychological impact of predictions on patients, and respect the fundamental principle of "first, do no harm."

```python
# pseudocode
def healthcare_problem_validation(problem_spec):
    """
    Specialized validation for healthcare ML problems
    Ensures clinical relevance and safety
    """
    
    validation_results = {
        "clinical_validity": {},
        "regulatory_compliance": {},
        "ethical_considerations": {},
        "safety_assessment": {}
    }
    
    // Clinical validity check
    clinical_review = {
        "actionability": assess_clinical_actionability(problem_spec),
        "timing": verify_intervention_window(problem_spec),
        "clinical_significance": check_effect_size_relevance(problem_spec),
        "workflow_integration": evaluate_workflow_fit(problem_spec)
    }
    
    IF clinical_review.actionability == "NOT_ACTIONABLE":
        validation_results.clinical_validity["verdict"] = "FAIL"
        validation_results.clinical_validity["reason"] = "Predictions don't enable clinical action"
    
    // Regulatory compliance
    regulatory_requirements = get_regulatory_framework(problem_spec.domain)
    FOR each requirement in regulatory_requirements:
        IF requirement.type == "EXPLAINABILITY":
            IF problem_spec.model_type in ["deep_learning", "ensemble"]:
                validation_results.regulatory_compliance["risk"] = "HIGH"
                validation_results.regulatory_compliance["mitigation"] = "Need interpretable model"
        
        IF requirement.type == "VALIDATION":
            validation_results.regulatory_compliance["needed"] = {
                "prospective_study": requirement.prospective_required,
                "external_validation": requirement.external_sites_needed,
                "sample_size": calculate_clinical_trial_size(problem_spec)
            }
    
    // Safety assessment
    failure_modes = analyze_failure_modes(problem_spec)
    FOR each failure_mode in failure_modes:
        harm_assessment = {
            "failure_type": failure_mode.type,
            "probability": failure_mode.likelihood,
            "severity": assess_patient_harm(failure_mode),
            "detectability": assess_detection_capability(failure_mode)
        }
        
        risk_score = harm_assessment.probability * harm_assessment.severity / harm_assessment.detectability
        
        IF risk_score > ACCEPTABLE_RISK_THRESHOLD:
            validation_results.safety_assessment["unacceptable_risks"].append(harm_assessment)
    
    return validation_results
```

Financial services applications must navigate a complex web of regulations, fairness requirements, and adversarial actors. Problem understanding in this domain must account for the reflexive nature of financial predictions—a model that predicts loan default might influence lending decisions in ways that change the default patterns themselves. The requirement for explainable decisions under regulations like the Equal Credit Opportunity Act fundamentally constrains the solution space. The presence of adversarial actors attempting to game the system means that problems must be defined not just for current patterns but for how those patterns might evolve in response to the model's deployment.

Retail and e-commerce applications face the challenge of extreme scale and real-time requirements while operating on thin margins that constrain investment. Problem understanding must account for the highly seasonal nature of retail data, the cold-start problem for new products or customers, and the complex interplay between online and offline channels. A recommendation system must be defined not just in terms of relevance but also considering inventory constraints, margin optimization, and long-term customer value.

Manufacturing and industrial applications bring unique constraints around reliability, safety, and integration with existing systems. Problem understanding must account for the cost of false positives in predictive maintenance (unnecessary downtime) versus false negatives (catastrophic failure). The limited availability of failure examples for training, the physics-based constraints on what patterns are possible, and the need for predictions that operators can understand and trust all shape how problems must be defined.

## Practical Tools and Templates

To support systematic problem understanding, practitioners benefit from structured tools and templates that guide thinking and ensure completeness. These tools shouldn't be treated as rigid forms to fill out but as frameworks that prompt the right questions and capture critical decisions.

![](images/ml-problem-understanding-canva.svg)

The Problem Understanding Canvas serves as a central artifact for capturing and communicating problem definition. Unlike traditional requirements documents that often run to dozens of pages of prose, the canvas provides a single-page visual representation that all stakeholders can quickly grasp and reference. The canvas structures thinking around nine key areas: the core problem statement occupies the center, surrounded by stakeholders, success metrics, constraints, available data, target definition, assumptions, risks, and dependencies. This visual arrangement emphasizes the interconnected nature of these elements—changing the target definition might affect success metrics, new constraints might introduce additional risks, different stakeholders might have conflicting success criteria.

The Feasibility Assessment Matrix provides a structured approach to evaluating whether a problem as defined can actually be solved. The matrix examines feasibility across multiple dimensions—statistical, technical, business, and ethical—with specific criteria for each. Statistical feasibility examines whether sufficient signal exists in the data, whether sample sizes are adequate, and whether the problem exhibits learnable patterns. Technical feasibility evaluates whether required latencies can be met, whether necessary infrastructure exists, and whether the team has appropriate skills. Business feasibility analyzes whether the expected value justifies the investment, whether the organization can act on predictions, and whether stakeholders will accept the solution. Ethical feasibility confirms whether fairness requirements can be met, whether privacy can be preserved, and whether decisions can be adequately explained.

The Stakeholder Alignment Tracker helps manage the complex web of perspectives and requirements that characterize machine learning projects. Different stakeholders often have different mental models of the problem, different success criteria, and different constraints they consider non-negotiable. The tracker captures each stakeholder's perspective, identifies areas of alignment and conflict, and documents resolution strategies. This tool proves particularly valuable when conflicts arise during development—having documented initial agreements prevents revisionist history and provides a basis for negotiation.

The Data Reality Checklist forces teams to confront the often significant gaps between available data and problem requirements. The checklist examines not just what data exists but when it becomes available, how it's collected, what biases it might contain, and how it might differ between training and production environments. This systematic examination often reveals fatal flaws in problem definition early, before significant resources are invested in development.

## Case Studies in Problem Understanding

Examining real-world applications of Polya's framework reveals both the power of proper problem understanding and the consequences of its neglect. These cases, drawn from actual machine learning projects, illustrate how the principles discussed throughout this article play out in practice.

Consider a major retail bank that embarked on an ambitious project to use machine learning for credit card fraud detection. The initial problem statement seemed clear enough: identify fraudulent transactions to prevent losses. The team immediately began exploring sophisticated deep learning approaches, excited by recent advances in anomaly detection. They assembled a massive dataset of historical transactions, engineered hundreds of features, and achieved impressive results on their test set, with precision and recall metrics that suggested the model would save millions of dollars annually.

The deployment was a disaster. The model, trained on historical data where fraud patterns were identified after thorough investigation, required information that wasn't available in real-time. The latency requirements of the payment network—transactions must be approved or declined within 100 milliseconds—made most of the engineered features impossible to calculate. The model's high precision came at the cost of flagging many legitimate transactions from customers traveling abroad or making unusual but legitimate purchases, leading to frustrated customers and abandoned transactions. Most critically, the team had optimized for detecting known fraud patterns, but fraudsters quickly adapted their techniques, rendering the model ineffective within weeks.

A proper application of Polya's framework would have revealed these issues before any model development began. Understanding the unknown would have clarified that the problem wasn't just identifying fraud, but identifying fraud in real-time, with limited information, in a way that minimizes both losses and customer friction, against an adversarial opponent who adapts to detection methods. Understanding the data would have revealed the temporal constraints on feature availability and the fundamental difference between training data (with complete information post-investigation) and production data (with only real-time transaction details). Understanding the conditions would have surfaced the strict latency requirements, the customer experience constraints, and the need for continuous adaptation.

In contrast, consider a logistics company that successfully applied Polya's framework to develop a package delivery time prediction system. Rather than jumping directly to solution development, the team spent considerable time understanding the problem's nuances. They recognized that the unknown wasn't simply delivery time, but the probability distribution of delivery times, as different use cases required different aspects of this distribution. Customer communications needed accurate expected delivery dates, route planning required worst-case estimates, and capacity planning needed average throughput predictions.

The team's data understanding phase revealed that historical delivery data exhibited strong seasonal patterns, weather dependencies, and significant differences between urban and rural routes. They discovered that GPS tracking data, while abundant, had systematic biases in certain geographic areas where signal quality was poor. They identified that new delivery partners had different performance patterns than experienced ones, requiring special handling in the model.

The condition analysis revealed complex, sometimes conflicting constraints. Predictions needed to be accurate enough to set customer expectations but conservative enough to account for unexpected delays. The system needed to integrate with existing route planning software that could only be updated quarterly. Predictions had to be explainable to delivery partners who might be penalized for late deliveries. By understanding these conditions upfront, the team designed a solution that balanced these requirements rather than optimizing for a single metric.

The result was a successful deployment that improved customer satisfaction, reduced support calls about delivery status, and enabled better resource planning. The key to success wasn't sophisticated algorithms—the final model was relatively simple—but rather the deep understanding of the problem that guided appropriate technical choices.

## From Understanding to Action

The transition from problem understanding to solution development should feel natural and inevitable when problem understanding has been done well. The unknown, clearly specified, determines what algorithms are appropriate and what metrics matter. The data, thoroughly understood, guides feature engineering and reveals necessary preprocessing steps. The conditions, carefully analyzed, shape the architecture and deployment strategy. Rather than facing a blank slate and endless possibilities, the team has a clear direction and bounded solution space.

Problem understanding also establishes clear checkpoints for project continuation. If the unknown cannot be specified precisely enough for all stakeholders to agree, the project isn't ready to proceed. If the data doesn't contain sufficient signal to predict the target, no amount of algorithmic sophistication will save the project. If the conditions are mutually incompatible, they must be renegotiated before development begins. These checkpoints, while sometimes disappointing when they halt promising projects, save organizations from the far greater disappointment of failed deployments and wasted resources.

```python
# pseudocode
def transition_to_planning(problem_understanding):
    """
    Validate problem understanding completeness and generate planning inputs
    Creates structured handoff from understanding to solution design
    """
    
    planning_package = {
        "algorithm_constraints": [],
        "architecture_requirements": [],
        "evaluation_strategy": {},
        "risk_mitigation": [],
        "success_criteria": {}
    }
    
    // Validate understanding completeness
    completeness_check = validate_understanding(problem_understanding)
    IF not completeness_check.is_complete:
        return {
            "ready": False,
            "missing_elements": completeness_check.gaps,
            "recommendation": "Address gaps before proceeding"
        }
    
    // Extract algorithm constraints from problem understanding
    IF problem_understanding.constraints.explainability == "REQUIRED":
        planning_package.algorithm_constraints.append("interpretable_models_only")
    
    IF problem_understanding.constraints.latency < 100:
        planning_package.algorithm_constraints.append("simple_features_only")
        planning_package.algorithm_constraints.append("no_ensemble_methods")
    
    IF problem_understanding.data.sample_size < 10000:
        planning_package.algorithm_constraints.append("avoid_deep_learning")
        planning_package.algorithm_constraints.append("consider_transfer_learning")
    
    // Define architecture requirements
    IF problem_understanding.target.update_frequency == "real_time":
        planning_package.architecture_requirements.append("streaming_architecture")
        planning_package.architecture_requirements.append("online_learning_capability")
    
    IF problem_understanding.data.volume > "1TB":
        planning_package.architecture_requirements.append("distributed_processing")
        planning_package.architecture_requirements.append("feature_store_needed")
    
    // Create evaluation strategy
    planning_package.evaluation_strategy = {
        "primary_metric": map_to_metric(problem_understanding.success_criteria.primary),
        "guardrail_metrics": map_to_metrics(problem_understanding.success_criteria.guardrails),
        "slice_evaluations": identify_critical_segments(problem_understanding.stakeholders),
        "temporal_validation": design_time_based_splits(problem_understanding.data),
        "production_simulation": create_production_test_plan(problem_understanding.constraints)
    }
    
    // Risk mitigation planning
    FOR each risk in problem_understanding.risks:
        mitigation = {
            "risk": risk.description,
            "likelihood": risk.probability,
            "impact": risk.severity,
            "mitigation_strategy": generate_mitigation_plan(risk),
            "monitoring_approach": define_risk_monitoring(risk),
            "contingency": create_fallback_plan(risk)
        }
        planning_package.risk_mitigation.append(mitigation)
    
    // Success criteria translation
    planning_package.success_criteria = {
        "technical": translate_business_to_technical(problem_understanding.success_metrics),
        "business": problem_understanding.success_metrics,
        "deployment": define_deployment_criteria(problem_understanding.constraints),
        "maintenance": establish_monitoring_thresholds(problem_understanding)
    }
    
    return {
        "ready": True,
        "planning_package": planning_package,
        "next_steps": generate_planning_roadmap(planning_package)
    }
```

The documentation generated during problem understanding becomes the project's north star, referenced throughout development when difficult decisions arise. Should we invest time in engineering this complex feature? The problem understanding tells us whether it addresses a core aspect of the unknown. Should we use a more complex model that slightly improves accuracy? The condition analysis tells us whether the added complexity violates our explainability or latency requirements. Should we delay deployment to gather more training data? The feasibility assessment tells us whether additional data will meaningfully improve our ability to solve the actual problem.

Perhaps most importantly, thorough problem understanding creates aligned expectations among all stakeholders. Technical teams understand not just what to build but why it matters. Business stakeholders understand not just what the model will predict but what limitations and uncertainties remain. Users understand not just how to interpret predictions but when to trust them and when to apply human judgment. This shared understanding prevents the disappointment and distrust that often accompany machine learning deployments where different groups had different, unspoken expectations.

## Conclusion: The Compound Returns of Problem Understanding

Polya's insight that understanding the problem is half the solution proves even more true in machine learning than in the mathematical contexts he originally addressed. The complexity of modern AI systems, the probabilistic nature of their outputs, and the organizational challenges of their deployment all amplify the importance of thorough problem understanding. Time invested in this phase pays compound returns throughout the project lifecycle.

The cascade effect of problem misunderstanding that we examined at the beginning of this article works in reverse for problem understanding done well. Clear problem definition leads to appropriate technical choices, which enable efficient implementation, which results in successful deployment. Each phase builds naturally on the previous one rather than requiring constant revision and rework. The team proceeds with confidence rather than uncertainty, stakeholders remain aligned rather than developing divergent expectations, and the final solution actually solves the intended problem rather than an imagined one.

As we proceed to Part 2 of this series, "Devising a Plan," we'll build on the foundation established through problem understanding. With a clear specification of the unknown, a thorough understanding of the data, and a complete picture of the constraints, we can explore how Polya's strategies for finding connections to known problems, decomposing complex challenges, and working backward from desired outcomes translate into concrete approaches for algorithm selection, experiment design, and system architecture. The plan that emerges will be grounded in reality rather than wishful thinking, ambitious yet achievable, sophisticated where necessary but simple where possible.

The discipline of problem understanding that Polya advocated requires patience in a field that celebrates rapid iteration and quick deployment. It requires humility in acknowledging what we don't know before proclaiming what we can predict. It requires courage in telling stakeholders that their problem as stated cannot be solved rather than building something that appears to work but fails in practice. Yet this patience, humility, and courage are precisely what distinguish successful machine learning initiatives from the vast majority that fail to deliver value.

In our age of readily available algorithms, powerful computing resources, and abundant data, the bottleneck in machine learning success is rarely technical capability. Instead, it's the fundamental understanding of what problem we're trying to solve, what information we have to solve it with, and what constraints bound our solution. Polya's framework, developed in an era before computers, provides timeless wisdom for navigating these challenges. By truly understanding the problem before attempting to solve it, we transform machine learning from an exercise in technical sophistication to a practical tool for creating real value.

The journey from vague business objectives to precise problem specifications, from raw data to understood information, from conflicting constraints to feasible solution spaces—this is the real work of data science. It's less glamorous than training neural networks or optimizing hyperparameters, but it's infinitely more valuable. For in the end, a perfectly executed solution to the wrong problem is worthless, while even an imperfect solution to the right problem creates value.

As practitioners, we must resist the temptation to rush past problem understanding in our eagerness to build solutions. As leaders, we must create space and time for teams to deeply understand problems before expecting solutions. As an industry, we must recognize that the highest-leverage improvements in AI success rates will come not from better algorithms but from better problem understanding.

Polya gave us the tools. The failures around us show the cost of ignoring them. The successes, though rarer, show the rewards of applying them diligently. The choice, and the responsibility, is ours.


![](images/ml-problem-understanding-framework.svg)

---

*This article is Part 1 of a four-part series on applying Polya's problem-solving framework to data science and machine learning. Continue with [Part 2: Devising a Plan], where we explore how to transform problem understanding into concrete technical strategies, [Part 3: Carrying Out the Plan], which addresses implementation challenges and best practices, and [Part 4: Looking Back], which covers evaluation, iteration, and continuous improvement.*

*The principles and frameworks presented here have been developed through analysis of hundreds of ML projects across industries. While each project is unique, the patterns of success and failure repeat with remarkable consistency. By learning from these patterns and applying Polya's timeless wisdom, we can dramatically improve our chances of building ML systems that deliver real value.*
